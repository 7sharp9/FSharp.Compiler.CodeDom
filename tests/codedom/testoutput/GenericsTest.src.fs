
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

namespace global

namespace TestNamespace
    // Generated by F# CodeDom
    #nowarn "49" // uppercase argument names
    #nowarn "67" // this type test or downcast will always hold
    #nowarn "66" // this upcast is unnecessary - the types are identical
    #nowarn "58" // possible incorrect indentation..
    #nowarn "57" // do not use create_DelegateEvent
    #nowarn "51" // address-of operator can occur in the code
    #nowarn "1183" // unused 'this' reference
    open System
    open System.Collections.Generic
    
    exception ReturnException12248e210dfc46b9a660aa8eddb00642 of obj
    exception ReturnNoneException12248e210dfc46b9a660aa8eddb00642
    [<AutoOpen>]
    module FuncConvertFinalOverload12248e210dfc46b9a660aa8eddb00642 =
      // This extension member adds to the FuncConvert type and is the last resort member in the method overloading rules. 
      type global.Microsoft.FSharp.Core.FuncConvert with
          /// A utility function to convert function values from tupled to curried form
          static member FuncFromTupled (f:'T -> 'Res) = f
    
    type
        
        MyDictionary<'K, 'V when 'K :> System.IComparable and 'K :> IComparable<'K> and 'K : (new:unit->'K) and 'V :> IList<string>> = class
            inherit Dictionary<'K, 'V> 
            new() as this =
                {
                }
            abstract Calculate<'S, 'T when 'S : (new:unit->'S)> : int * int -> int
            default this.Calculate<'S, 'T when 'S : (new:unit->'S)>  (value1:int, value2:int) =
                let mutable value1 = value1
                let mutable value2 = value2
                (value1 * value2)
        end
    
    and
        
        Test = class
            new() as this =
                {
                }
            abstract MyMethod : unit -> int
            default this.MyMethod  () =
                let mutable (dReturn:int) = 0
                let mutable (dict:MyDictionary<int, List<string>>) = new MyDictionary<int, List<string>>()
                dReturn <- dict.Calculate<int, int>(25, 11)
                dReturn
        end